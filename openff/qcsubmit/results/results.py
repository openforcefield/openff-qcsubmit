"""
A module which contains convenience classes for referencing, retrieving and filtering
results from a QCFractal instance.
"""
import abc
from collections import defaultdict
from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    Iterable,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
    Union,
)

import qcportal
from openff.toolkit.topology import Molecule
from pydantic import BaseModel, Field, validator
from qcportal.collections import OptimizationDataset, TorsionDriveDataset
from qcportal.collections.collection import Collection as QCCollection
from qcportal.collections.dataset import Dataset, MoleculeEntry
from qcportal.models import OptimizationRecord, ResultRecord, TorsionDriveRecord
from qcportal.models.common_models import DriverEnum, ObjectId
from qcportal.models.records import RecordBase
from typing_extensions import Literal

from openff.qcsubmit.common_structures import Metadata
from openff.qcsubmit.datasets import BasicDataset
from openff.qcsubmit.exceptions import RecordTypeError
from openff.qcsubmit.results.caching import (
    cached_query_basic_results,
    cached_query_molecules,
    cached_query_optimization_results,
    cached_query_torsion_drive_results,
)

if TYPE_CHECKING:
    from openff.qcsubmit.results.filters import ResultFilter

T = TypeVar("T")
S = TypeVar("S")


class _BaseResult(BaseModel, abc.ABC):
    """The base model for storing information about a QC record generated by
    QCFractal."""

    type: Literal["base"]

    record_id: ObjectId = Field(
        ...,
        description="The unique id assigned to the record referenced by this result.",
    )

    cmiles: str = Field(
        ...,
        description="The canonical, isomeric, explicit hydrogen, mapped SMILES "
        "representation of the molecule that this record was created for.",
    )
    inchi_key: str = Field(
        ...,
        description="The InChI key generated from the ``cmiles`` representation. This "
        "may be used as a hash for the molecule referenced by this record.",
    )

    @property
    def molecule(self) -> Molecule:
        """Returns an OpenFF molecule object created from this records
        CMILES which is in the correct order to align with the QCArchive records.
        """
        return Molecule.from_mapped_smiles(self.cmiles)


class _BaseResultCollection(BaseModel, abc.ABC):
    """The base model for storing references to a collection of QC records generated by
    QCFractal which are not necessarily stored in the same datasets.
    """

    entries: Dict[str, List[_BaseResult]] = Field(
        ...,
        description="The entries stored in this collection in a dictionary of the form "
        "``collection.entries['qcfractal_address'] = [record_1, ..., record_N]``.",
    )

    provenance: Dict[str, Any] = Field(
        {},
        description="A dictionary which can contain provenance information about "
        "how and why this collection was curated.",
    )

    @validator("entries")
    def _validate_entries(cls, values):

        for client_address, entries in values.items():

            record_ids = {entry.record_id for entry in entries}
            assert len(entries) == len(
                record_ids
            ), f"duplicate entries were found for {client_address}"

        return values

    @property
    def n_results(self) -> int:
        """Returns the number of results in this collection."""
        return sum(len(entries) for entries in self.entries.values())

    @property
    def n_molecules(self) -> int:
        """Returns the number of unique molecules referenced by this collection."""
        return len(
            {entry.inchi_key for entries in self.entries.values() for entry in entries}
        )

    @classmethod
    @abc.abstractmethod
    def from_datasets(
        cls: T,
        datasets: Union[QCCollection, Iterable[QCCollection]],
        spec_name: str = "default",
    ) -> T:
        """Retrieve the COMPLETE record ids referenced by the specified datasets.

        Args:
            datasets: The datasets to retrieve the records from.
            spec_name: The name of the QC specification that the records to retrieve
                should have been computed using.

        Returns:
            A results collection object containing the record ids and a minimal amount
            of associated metadata such as the CMILES of the associated molecule.
        """
        raise NotImplementedError()

    @classmethod
    @abc.abstractmethod
    def from_server(
        cls: T,
        client: qcportal.FractalClient,
        datasets: Union[str, Iterable[str]],
        spec_name: str = "default",
    ) -> T:
        """Retrieve (and deduplicate) the COMPLETE record ids referenced by the
        specified datasets.

        Args:
            client: The fractal client that should be used to interface with the running
                QCFractal instance which stores the datasets and their associated
                results records.
            datasets: The names of the datasets
            spec_name: The name of the QC specification that the records to retrieve
                should have been computed using.

        Returns:
            A results collection object containing the record ids and a minimal amount
            of associated metadata such as the CMILES of the associated molecule.
        """
        raise NotImplementedError()

    @classmethod
    def _validate_record_types(
        cls, records: List[ResultRecord], expected_type: Type[RecordBase]
    ):
        """A helper method which raises a ``RecordTypeError`` if all records in the list
        are not of the specified type."""

        incorrect_types = [
            record for record in records if not isinstance(record, expected_type)
        ]

        if len(incorrect_types) > 0:

            incorrect_types_dict = defaultdict(set)

            for record in incorrect_types:
                incorrect_types_dict[record.__class__.__name__].add(record.id)

            raise RecordTypeError(
                f"The collection contained a records which were of the wrong type. "
                f"This collection should only store {expected_type.__name__} records."
                f"{dict(**incorrect_types_dict)}"
            )

    @abc.abstractmethod
    def to_records(self) -> List[Tuple[RecordBase, Molecule]]:
        """Returns the native QCPortal record objects for each of the records referenced
        in this collection along with a corresponding OpenFF molecule object.
        """
        raise NotImplementedError()

    def filter(self, *filters: "ResultFilter"):
        """Filter this collection by applying a set of filters sequentially, returning
        a new collection containing only the retained entries.

        Notes:
            Information about any applied filters will be stored in the provenance
            dictionary in the 'applied-filters' field. Any existing information in
            this field will be overwritten here.

        Args:
            filters: The filters to apply, in the order to apply them in.

        Returns:
            The collection containing only the retained entries.
        """

        filtered_collection = self.copy(deep=True)

        for collection_filter in filters:
            filtered_collection = collection_filter.apply(filtered_collection)

        return filtered_collection


class BasicResult(_BaseResult):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    type: Literal["basic"] = "basic"


class BasicResultCollection(_BaseResultCollection):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    entries: Dict[str, List[BasicResult]] = Field(
        ...,
        description="The entries stored in this collection in a dictionary of the form "
        "``collection.entries['qcfractal_address'] = [record_1, ..., record_N]``.",
    )

    @classmethod
    def from_datasets(
        cls,
        datasets: Union[Dataset, Iterable[Dataset]],
        spec_name: str = "default",
    ) -> "BasicResultCollection":

        if isinstance(datasets, QCCollection):
            datasets = [datasets]

        if not all(isinstance(dataset, Dataset) for dataset in datasets):

            raise TypeError(
                "A ``BasicResultCollection`` can only be created from ``Dataset`` "
                "objects."
            )

        result_records = defaultdict(dict)
        molecules = {}

        for dataset in datasets:

            client = dataset.client

            dataset_specs = {
                spec: {"method": method, "basis": basis, "program": program}
                for _, program, method, basis, spec in dataset.data.history
            }

            if spec_name not in dataset_specs:
                raise KeyError(
                    f"The {dataset.data.name} dataset does not contain a '{spec_name}' "
                    f"compute specification"
                )

            # query the database to get all of the result records requested
            query = dataset.get_records(**dataset_specs[spec_name])

            entries: Dict[str, MoleculeEntry] = {
                entry.name: entry for entry in dataset.data.records
            }

            # Query the server for the molecules associated with these entries.
            # We only try to pull down ones which haven't already been retrieved.
            molecules.update(
                {
                    molecule.id: molecule
                    for molecule in cached_query_molecules(
                        client.address,
                        [
                            entry.molecule_id
                            for entry in entries.values()
                            if entry.molecule_id not in molecules
                        ],
                    )
                }
            )

            result_records[client.address].update(
                {
                    result.id: BasicResult(
                        record_id=result.id,
                        cmiles=molecules[entries[index].molecule_id].extras[
                            "canonical_isomeric_explicit_hydrogen_mapped_smiles"
                        ],
                        inchi_key=Molecule.from_mapped_smiles(
                            molecules[entries[index].molecule_id].extras[
                                "canonical_isomeric_explicit_hydrogen_mapped_smiles"
                            ],
                            # Undefined stereochemistry is not expected however there
                            # may be some TK specific edge cases we don't want
                            # exceptions for such as OE and nitrogen stereochemistry.
                            allow_undefined_stereo=True,
                        ).to_inchikey(fixed_hydrogens=False),
                    )
                    for index, (result,) in query.iterrows()
                    if result.status.value.upper() == "COMPLETE"
                }
            )

        return cls(
            entries={
                address: [*entries.values()]
                for address, entries in result_records.items()
            }
        )

    @classmethod
    def from_server(
        cls,
        client: qcportal.FractalClient,
        datasets: Union[str, Iterable[str]],
        spec_name: str = "default",
    ) -> "BasicResultCollection":

        if isinstance(datasets, str):
            datasets = [datasets]

        # noinspection PyTypeChecker
        return cls.from_datasets(
            [
                client.get_collection("Dataset", dataset_name)
                for dataset_name in datasets
            ],
            spec_name,
        )

    def to_records(self) -> List[Tuple[ResultRecord, Molecule]]:
        """Returns the native QCPortal record objects for each of the records referenced
        in this collection along with a corresponding OpenFF molecule object.

        Each molecule will contain the conformer referenced by the record.
        """

        records_and_molecules = [
            result
            for client_address, entries in self.entries.items()
            for result in cached_query_basic_results(client_address, entries)
        ]

        records, _ = zip(*records_and_molecules)

        self._validate_record_types(records, ResultRecord)

        return records_and_molecules


class OptimizationResult(_BaseResult):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    type: Literal["optimization"] = "optimization"


class OptimizationResultCollection(_BaseResultCollection):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    entries: Dict[str, List[OptimizationResult]] = Field(
        ...,
        description="The entries stored in this collection in a dictionary of the form "
        "``collection.entries['qcfractal_address'] = [record_1, ..., record_N]``.",
    )

    @classmethod
    def from_datasets(
        cls,
        datasets: Union[OptimizationDataset, Iterable[OptimizationDataset]],
        spec_name: str = "default",
    ) -> "OptimizationResultCollection":

        if isinstance(datasets, QCCollection):
            datasets = [datasets]

        if not all(isinstance(dataset, OptimizationDataset) for dataset in datasets):

            raise TypeError(
                "A ``OptimizationResultCollection`` can only be created from "
                "``OptimizationDataset`` objects."
            )

        result_records = defaultdict(dict)

        for dataset in datasets:

            client = dataset.client
            query = dataset.query(spec_name)

            result_records[client.address].update(
                {
                    query[entry.name].id: OptimizationResult(
                        record_id=query[entry.name].id,
                        cmiles=entry.attributes[
                            "canonical_isomeric_explicit_hydrogen_mapped_smiles"
                        ],
                        inchi_key=entry.attributes["inchi_key"],
                    )
                    for entry in dataset.data.records.values()
                    if query[entry.name].status.value.upper() == "COMPLETE"
                }
            )

        return cls(
            entries={
                address: [*entries.values()]
                for address, entries in result_records.items()
            }
        )

    @classmethod
    def from_server(
        cls,
        client: qcportal.FractalClient,
        datasets: Union[str, Iterable[str]],
        spec_name: str = "default",
    ) -> "OptimizationResultCollection":

        if isinstance(datasets, str):
            datasets = [datasets]

        # noinspection PyTypeChecker
        return cls.from_datasets(
            [
                client.get_collection("OptimizationDataset", dataset_name)
                for dataset_name in datasets
            ],
            spec_name,
        )

    def to_records(self) -> List[Tuple[OptimizationRecord, Molecule]]:
        """Returns the native QCPortal record objects for each of the records referenced
        in this collection along with a corresponding OpenFF molecule object.

        Each molecule will contain the minimum energy conformer referenced by the
        record.
        """

        records_and_molecules = [
            result
            for client_address, entries in self.entries.items()
            for result in cached_query_optimization_results(client_address, entries)
        ]

        records, _ = zip(*records_and_molecules)

        self._validate_record_types(records, OptimizationRecord)

        return records_and_molecules

    def create_basic_dataset(
        self,
        dataset_name: str,
        description: str,
        tagline: str,
        driver: DriverEnum,
        metadata: Optional[Metadata] = None,
    ) -> BasicDataset:
        """Create a basic dataset from the results of the current dataset.

        Notes:
            * This may be used, for example, to evaluate the hessians of each optimized
              geometry.

        Parameters:
            dataset_name: The name that will be given to the new dataset.
            tagline: The tagline that should be given to the new dataset.
            description: The description that should be given to the new dataset.
            metadata: The metadata for the new dataset.
            driver: The driver to be used on the basic dataset.

        Returns:
            The created basic dataset.
        """
        raise NotImplementedError()


class TorsionDriveResult(_BaseResult):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    type: Literal["torsion"] = "torsion"


class TorsionDriveResultCollection(_BaseResultCollection):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    entries: Dict[str, List[TorsionDriveResult]] = Field(
        ...,
        description="The entries stored in this collection in a dictionary of the form "
        "``collection.entries['qcfractal_address'] = [record_1, ..., record_N]``.",
    )

    @classmethod
    def from_datasets(
        cls,
        datasets: Union[TorsionDriveDataset, Iterable[TorsionDriveDataset]],
        spec_name: str = "default",
    ) -> "TorsionDriveResultCollection":

        if isinstance(datasets, QCCollection):
            datasets = [datasets]

        if not all(isinstance(dataset, TorsionDriveDataset) for dataset in datasets):

            raise TypeError(
                "A ``TorsionDriveResultCollection`` can only be created from "
                "``TorsionDriveDataset`` objects."
            )

        result_records = defaultdict(dict)

        for dataset in datasets:

            client = dataset.client
            query = dataset.query(spec_name)

            result_records[client.address].update(
                {
                    query[entry.name].id: TorsionDriveResult(
                        record_id=query[entry.name].id,
                        cmiles=entry.attributes[
                            "canonical_isomeric_explicit_hydrogen_mapped_smiles"
                        ],
                        inchi_key=entry.attributes["inchi_key"],
                    )
                    for entry in dataset.data.records.values()
                    if query[entry.name].status.value.upper() == "COMPLETE"
                }
            )

        return cls(
            entries={
                address: [*entries.values()]
                for address, entries in result_records.items()
            }
        )

    @classmethod
    def from_server(
        cls,
        client: qcportal.FractalClient,
        datasets: Union[str, Iterable[str]],
        spec_name: str = "default",
    ) -> "TorsionDriveResultCollection":

        if isinstance(datasets, str):
            datasets = [datasets]

        # noinspection PyTypeChecker
        return cls.from_datasets(
            [
                client.get_collection("TorsionDriveDataset", dataset_name)
                for dataset_name in datasets
            ],
            spec_name,
        )

    def to_records(self) -> List[Tuple[TorsionDriveRecord, Molecule]]:

        """Returns the native QCPortal record objects for each of the records referenced
        in this collection along with a corresponding OpenFF molecule object.

        Each molecule will contain the minimum energy conformer referenced by the
        record.
        """

        records_and_molecules = [
            result
            for client_address, entries in self.entries.items()
            for result in cached_query_torsion_drive_results(client_address, entries)
        ]

        records, _ = zip(*records_and_molecules)

        self._validate_record_types(records, TorsionDriveRecord)

        return records_and_molecules

    def create_optimization_dataset(
        self,
        dataset_name: str,
        description: str,
        tagline: str,
        metadata: Optional[Metadata] = None,
    ) -> OptimizationDataset:
        """Create an optimization dataset from the results of the current torsion drive
        dataset. This will result in many constrained optimizations for each molecule.

        Note:
            The final geometry of each torsiondrive constrained optimization is supplied
            as a starting geometry.

        Parameters:
            dataset_name: The name that will be given to the new dataset.
            tagline: The tagline that should be given to the new dataset.
            description: The description that should be given to the new dataset.
            metadata: The metadata for the new dataset.

        Returns:
            The created optimization dataset.
        """
        raise NotImplementedError()
