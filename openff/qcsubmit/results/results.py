"""
A module which contains convenience classes for referencing, retrieving and filtering
results from a QCFractal instance.
"""
import abc
from typing import Callable, Dict, Iterable, List, TypeVar, Union

import qcportal
from openff.toolkit.topology import Molecule
from pydantic import BaseModel, Field, validator
from qcportal.collections.dataset import MoleculeEntry
from qcportal.models import ResultRecord
from qcportal.models.common_models import ObjectId
from typing_extensions import Literal

T = TypeVar("T")
S = TypeVar("S")


class _BaseResult(BaseModel, abc.ABC):
    """The base model for storing information about a QC record generated by
    QCFractal."""

    type: Literal["base"]

    record_id: ObjectId = Field(
        ...,
        description="The unique id assigned to the record referenced by this result.",
    )
    cmiles: str = Field(
        ...,
        description="The canonical, isomeric, explicit hydrogen, mapped SMILES "
        "representation of the molecule that this record was created for.",
    )

    @property
    def molecule(self) -> Molecule:
        """Returns an OpenFF molecule object created from this records
        CMILES which is in the correct order to align with the QCArchive records.
        """
        return Molecule.from_mapped_smiles(self.cmiles)


class _BaseResultCollection(BaseModel, abc.ABC):
    """The base model for storing references to a collection of QC records generated by
    QCFractal which are not necessarily stored in the same datasets.
    """

    entries: Dict[str, List[_BaseResult]] = Field(
        ...,
        description="The entries stored in this collection in a dictionary of the form"
        "``collection.entries['qcfractal_address'] = [record_1, ..., record_N]``.",
    )

    @validator("entries")
    def _validate_entries(cls, values):

        record_ids = {value.record_id for value in values}
        assert len(values) == len(record_ids), "duplicate entries were found"

    @property
    def n_entries(self) -> int:
        """Returns the number of results in this collection."""
        return sum(len(entries) for entries in self.entries.values())

    @property
    def n_molecules(self) -> int:
        """Returns the number of unique molecules referenced by this collection."""
        return len(
            {entry.cmiles for entries in self.entries.values() for entry in entries}
        )

    @staticmethod
    def _query_in_chunks(
        query_function: Callable[[List[str]], S], query_ids: List[str], query_limit: int
    ) -> List[S]:
        """Take the query list of ids and query the database in query limit chunks."""

        client_results = [
            result
            for i in range(0, len(query_ids), query_limit)
            for result in query_function(query_ids[i : i + query_limit])
        ]

        return client_results

    @classmethod
    @abc.abstractmethod
    def from_server(
        cls: T,
        client: qcportal.FractalClient,
        datasets: Iterable[str],
        spec_name: str = "default",
    ) -> T:
        """Retrieve (and deduplicate) the COMPLETE record ids referenced by the
        specified datasets.

        Args:
            client: The fractal client that should be used to interface with the running
                QCFractal instance which stores the datasets and their associated
                results records.
            datasets: The names of the datasets
            spec_name: The name of the QC specification that the records to retrieve
                should have been computed using.

        Returns:
            A results collection object containing the record ids and a minimal amount
            of associated metadata such as the CMILES of the associated molecule.
        """
        raise NotImplementedError()

    @abc.abstractmethod
    def to_records(self) -> List[ResultRecord]:
        """Returns the native QCPortal record objects for each of the records referenced
        in this collection.

        Notes
        -----
        * The records are retrieved from the server in batches
        """
        raise NotImplementedError()


class BasicResult(_BaseResult):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    type: Literal["basic"] = "basic"


class BasicResultCollection(_BaseResultCollection):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    entries: Dict[str, List[BasicResult]] = Field(
        ...,
        description="The entries stored in this collection in a dictionary of the form"
        "``collection.entries['qcfractal_address'] = [record_1, ..., record_N]``.",
    )

    @classmethod
    def from_server(
        cls,
        client: qcportal.FractalClient,
        datasets: Union[str, Iterable[str]],
        spec_name: str = "default",
    ) -> "BasicResultCollection":

        if isinstance(datasets, str):
            datasets = [datasets]

        result_records = {}
        molecules = {}

        for dataset_name in datasets:

            dataset = client.get_collection("Dataset", dataset_name)

            dataset_specs = {
                spec: {"method": method, "basis": basis, "program": program}
                for _, program, method, basis, spec in dataset.data.history
            }

            if spec_name not in dataset_specs:

                raise KeyError(
                    f"The {dataset_name} dataset does not contain a '{spec_name}' "
                    f"compute specification"
                )

            # query the database to get all of the result records requested
            query = dataset.get_records(**dataset_specs[spec_name])

            entries: Dict[str, MoleculeEntry] = {
                entry.name: entry for entry in dataset.data.records
            }

            # Query the server for the molecules associated with these entries.
            # We only try to pull down ones which haven't already been retrieved.
            molecules.update(
                {
                    molecule.id: molecule
                    for molecule in cls._query_in_chunks(
                        client.query_molecules,
                        [
                            entry.molecule_id
                            for entry in entries.values()
                            if entry.molecule_id not in molecules
                        ],
                        client.query_limit,
                    )
                }
            )

            result_records.update(
                {
                    result.id: BasicResult(
                        record_id=result.id,
                        cmiles=molecules[entries[index].molecule_id].extras[
                            "canonical_isomeric_explicit_hydrogen_mapped_smiles"
                        ],
                    )
                    for index, (result,) in query.iterrows()
                    if result.status.value.upper() == "COMPLETE"
                }
            )

        return cls(entries={client.address: [*result_records.values()]})


class OptimizationResult(_BaseResult):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    type: Literal["optimization"] = "optimization"


class OptimizationResultCollection(_BaseResultCollection):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    entries: Dict[str, List[OptimizationResult]] = Field(
        ...,
        description="The entries stored in this collection in a dictionary of the form"
        "``collection.entries['qcfractal_address'] = [record_1, ..., record_N]``.",
    )

    @classmethod
    def from_server(
        cls,
        client: qcportal.FractalClient,
        datasets: Union[str, Iterable[str]],
        spec_name: str = "default",
    ) -> "OptimizationResultCollection":

        if isinstance(datasets, str):
            datasets = [datasets]

        result_records = {}

        for dataset_name in datasets:

            dataset = client.get_collection("OptimizationDataset", dataset_name)
            query = dataset.query(spec_name)

            result_records.update(
                {
                    query[entry.name].id: OptimizationResult(
                        record_id=query[entry.name].id,
                        cmiles=entry.attributes[
                            "canonical_isomeric_explicit_hydrogen_mapped_smiles"
                        ],
                    )
                    for entry in dataset.data.records.values()
                    if query[entry.name].status.value.upper() == "COMPLETE"
                }
            )

        return cls(entries={client.address: [*result_records.values()]})


class TorsionDriveResult(_BaseResult):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    type: Literal["torsion"] = "torsion"


class TorsionDriveResultCollection(_BaseResultCollection):
    """A class which stores a reference to, and allows the retrieval of, data from
    a single result record stored in a QCFractal instance."""

    entries: Dict[str, List[TorsionDriveResult]] = Field(
        ...,
        description="The entries stored in this collection in a dictionary of the form"
        "``collection.entries['qcfractal_address'] = [record_1, ..., record_N]``.",
    )

    @classmethod
    def from_server(
        cls,
        client: qcportal.FractalClient,
        datasets: Union[str, Iterable[str]],
        spec_name: str = "default",
    ) -> "TorsionDriveResultCollection":

        if isinstance(datasets, str):
            datasets = [datasets]

        result_records = {}

        for dataset_name in datasets:

            dataset = client.get_collection("TorsionDriveDataset", dataset_name)
            query = dataset.query(spec_name)

            result_records.update(
                {
                    query[entry.name].id: TorsionDriveResult(
                        record_id=query[entry.name].id,
                        cmiles=entry.attributes[
                            "canonical_isomeric_explicit_hydrogen_mapped_smiles"
                        ],
                    )
                    for entry in dataset.data.records.values()
                    if query[entry.name].status.value.upper() == "COMPLETE"
                }
            )

        return cls(entries={client.address: [*result_records.values()]})
